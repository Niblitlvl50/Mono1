
#include "TextFunctions.h"
#include "System/File.h"
#include "Rendering/Texture/ITexture.h"
#include "Rendering/Texture/TextureFactory.h"
#include "Math/Vector.h"

#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype/stb_truetype.h"

#include <cstring>
#include <cstdio>
#include <unordered_map>
#include <cassert>

namespace
{
    constexpr int g_base = 32;
    constexpr int g_n_chars = 224;

    struct CharData
    {
        float xadvance;
        float xoffset;
        float yoffset;
        float width;
        float height;
        
        float texCoordX0;
        float texCoordY0;
        float texCoordX1;
        float texCoordY1;
    };

    struct FontData
    {
        mono::ITexturePtr texture;
        CharData chars[g_n_chars];
    };

    std::unordered_map<int, FontData> g_fonts;
}

void mono::LoadFont(int font_id, const char* font_file, float size, float scale)
{
    file::FilePtr font = file::OpenBinaryFile(font_file);
    
    std::vector<byte> font_buffer;
    file::FileRead(font, font_buffer);
    
    LoadFontRaw(font_id, font_buffer.data(), font_buffer.size(), size, scale);
}

void mono::LoadFontRaw(int font_id, const unsigned char* data_bytes, int data_size, float size, float scale)
{
    constexpr int width = 512;
    constexpr int height = 512;
    constexpr float texCoordXMulti = 1.0f / width;
    constexpr float texCoordYMulti = 1.0f / height;

    byte bitmap_data[width * height];
    stbtt_bakedchar char_data[g_n_chars];
    
    // The bitmap generated by this function has origo in the upper left corner,
    // thats why a bit down the y texture coordinate is flipped.
    stbtt_BakeFontBitmap(data_bytes, 0, size, bitmap_data, width, height, g_base, g_n_chars, char_data);

    FontData font_data;
    font_data.texture = mono::CreateTexture(bitmap_data, width, height, 1);

    for(int index = 0; index < g_n_chars; ++index)
    {
        const stbtt_bakedchar& baked_char = char_data[index];
        
        CharData& data = font_data.chars[index];
        data.width = (baked_char.x1 - baked_char.x0) * scale;
        data.height = (baked_char.y1 - baked_char.y0) * scale;
        data.xadvance = baked_char.xadvance * scale;
        data.xoffset = baked_char.xoff * scale;
        data.yoffset = (baked_char.yoff * scale) + data.height;
        data.texCoordX0 = baked_char.x0 * texCoordXMulti;
        data.texCoordY0 = baked_char.y1 * texCoordYMulti;
        data.texCoordX1 = baked_char.x1 * texCoordXMulti;
        data.texCoordY1 = baked_char.y0 * texCoordYMulti;
    }

    g_fonts.insert(std::make_pair(font_id, font_data));
}

void mono::UnloadFonts()
{
    g_fonts.clear();
}

mono::ITexturePtr mono::GetFontTexture(int font_id)
{
    return g_fonts.find(font_id)->second.texture;
}

mono::TextDefinition mono::GenerateVertexDataFromString(int font_id, const char* text, const math::Vector& pos, bool center)
{
    const uint32_t text_length = std::strlen(text);

    mono::TextDefinition text_def;
    text_def.chars = text_length;
    text_def.color = mono::Color::RGBA(1.0f, 1.0f, 1.0f);
    text_def.vertices.reserve(text_def.chars * 12);
    text_def.texcoords.reserve(text_def.chars * 12);
    
    float x_position = pos.x;
    float y_position = pos.y;
    
    if(center)
        x_position -= MeasureString(font_id, text).x / 2.0f;

    const FontData& font_data = g_fonts.find(font_id)->second;

    for(uint32_t index = 0; index < text_length; ++index)
    {
        const char text_char = text[index];
        const uint32_t char_index = static_cast<uint32_t>(text_char);

        // For the correct char we need to add base to the index.
        const uint32_t offset_index = char_index - g_base;
        const CharData& data = font_data.chars[offset_index];

        const float x0 = x_position + data.xoffset;
        const float y0 = y_position - data.yoffset;
        const float x1 = x0 + data.width;
        const float y1 = y0 + data.height;

        // First triangle
        text_def.vertices.emplace_back(x0);
        text_def.vertices.emplace_back(y0);
        text_def.vertices.emplace_back(x1);
        text_def.vertices.emplace_back(y1);
        text_def.vertices.emplace_back(x0);
        text_def.vertices.emplace_back(y1);

        text_def.texcoords.emplace_back(data.texCoordX0);
        text_def.texcoords.emplace_back(data.texCoordY0);
        text_def.texcoords.emplace_back(data.texCoordX1);
        text_def.texcoords.emplace_back(data.texCoordY1);
        text_def.texcoords.emplace_back(data.texCoordX0);
        text_def.texcoords.emplace_back(data.texCoordY1);
        
        // Second triangle
        text_def.vertices.emplace_back(x0);
        text_def.vertices.emplace_back(y0);
        text_def.vertices.emplace_back(x1);
        text_def.vertices.emplace_back(y0);
        text_def.vertices.emplace_back(x1);
        text_def.vertices.emplace_back(y1);

        text_def.texcoords.emplace_back(data.texCoordX0);
        text_def.texcoords.emplace_back(data.texCoordY0);
        text_def.texcoords.emplace_back(data.texCoordX1);
        text_def.texcoords.emplace_back(data.texCoordY0);
        text_def.texcoords.emplace_back(data.texCoordX1);
        text_def.texcoords.emplace_back(data.texCoordY1);
        
        // Add x size of char so that the next char is placed a little bit to the right.
        x_position += data.xadvance;
    }

    return text_def;
}

math::Vector mono::MeasureString(int font_id, const char* text)
{
    const FontData& font_data = g_fonts.find(font_id)->second;
    const uint32_t text_length = std::strlen(text);

    math::Vector size;
    
    for(uint32_t index = 0; index < text_length; ++index)
    {
        const char text_char = text[index];
        const uint32_t char_index = static_cast<uint32_t>(text_char);

        // For the correct char we need to add base to the index.
        const uint32_t offset_index = char_index - g_base;
        const CharData& data = font_data.chars[offset_index];

        size.x += data.xadvance;
        size.y = std::max(data.height, size.y);
    }

    return size;
}
